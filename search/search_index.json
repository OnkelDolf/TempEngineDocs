{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Docs for the doc god</p> <p></p> <p> </p>"},{"location":"API%20Reference/D3D11%20API/Defines/","title":"Defines","text":"<pre><code>#define EXPORT __declspec(selectany)\n#define ALIGN(bytes) __declspec(align(bytes))\n\n#define MAX_BONES_PER_MESH 64\n#define MAX_MODEL_MESHES 16\n#define MAX_MODEL_MATERIALS 4\n#define MAX_POINT_LIGHTS 8\n#define MAX_SPOT_LIGHTS 8\n\n#define MAX_MATERIAL_NAME_LENGTH 32\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Enums/BLENDSTATE/","title":"BLENDSTATE","text":"<pre><code>enum BLENDSTATE {\n\u00a0 \u00a0 BLENDSTATE_NULL, BLENDSTATE_OPAQUE, BLENDSTATE_ALPHA, BLENDSTATE_ADDITIVE, BLENDSTATE_COUNT\n};\n</code></pre> <p>Indicates which blendstate to switch to or is currently active.</p>"},{"location":"API%20Reference/D3D11%20API/Enums/BLENDSTATE/#associated-functions","title":"Associated functions","text":"<p>SetBlendState GetBlendState</p>"},{"location":"API%20Reference/D3D11%20API/Enums/MAT_FLAGS/","title":"MAT_FLAGS","text":"<pre><code>enum MAT_FLAGS {\n\u00a0 \u00a0 MAT_FLAGS_NONE = 0,\n\u00a0 \u00a0 MAT_FLAGS_DIFFUSE = 1 &lt;&lt; 0,\n\u00a0 \u00a0 MAT_FLAGS_NORMAL = 1 &lt;&lt; 1,\n\u00a0 \u00a0 MAT_FLAGS_MATERIAL0 = 1 &lt;&lt; 2,\n\u00a0 \u00a0 MAT_FLAGS_MATERIAL1 = 1 &lt;&lt; 3,\n\u00a0 \u00a0 MAT_FLAGS_ALL = MAT_FLAGS_DIFFUSE | MAT_FLAGS_NORMAL | MAT_FLAGS_MATERIAL0 | MAT_FLAGS_MATERIAL1,\n};\n</code></pre> <p>Defines what textures are loaded in the material.</p>"},{"location":"API%20Reference/D3D11%20API/Enums/MAT_FLAGS/#associated-structure","title":"Associated structure","text":"<p>Material</p>"},{"location":"API%20Reference/D3D11%20API/Functions/AddPointLight/","title":"AddPointLight","text":"<pre><code>extern int AddPointLight(PointLight* pointLight);\n</code></pre> <p>Adds a point light.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/AddPointLight/#usage","title":"Usage","text":"<pre><code>D3DAPI::PointLight pointlight;\n// Init the pointlight with required data\n\nD3DAPI::AddPointLight(&amp;pointlight);\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Functions/AddSpotLight/","title":"AddSpotLight","text":"<pre><code>extern int AddSpotLight(SpotLight* spotLight);\n</code></pre> <p>Adds spot light</p>"},{"location":"API%20Reference/D3D11%20API/Functions/AddSpotLight/#usage","title":"Usage","text":"<pre><code>D3DAPI::SpotLight spotlight;\n// Init the spotlight with required data\n\nD3DAPI::AddSpotLight(&amp;spotlight);\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Functions/ClearDsv/","title":"ClearDsv","text":"<pre><code>extern int ClearDsv(ID3D11DepthStencilView* dsv);\n</code></pre> <p>Clears a d3d11 depthbuffer</p>"},{"location":"API%20Reference/D3D11%20API/Functions/ClearDsv/#usage","title":"Usage","text":"<pre><code>ID3D11DepthStencilView* depthbuffer;\n\n...\n\nClearDsv(depthbuffer);\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Functions/ClearLights/","title":"ClearLights","text":"<pre><code>extern int ClearLights();\n</code></pre> <p>Clears all lights.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/ClearLights/#usage","title":"Usage","text":"<pre><code>D3DAPI::ClearLights();\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Functions/ClearRenderTarget/","title":"ClearRenderTarget","text":"<pre><code>extern int ClearRenderTarget(RenderTarget* renderTarget, Vector4 color = { 0.0f, 0.0f, 0.0f, 1.0f });\n</code></pre> <p>Clears a rendertarget with a specific color.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/ClearRenderTarget/#usage","title":"Usage","text":"<pre><code>D3DAPI::RenderTarget rendertarget;\nD3DAPI::CreateRenderTarget(800, 600, &amp;rendertarget);\n\n...\n\nD3DAPI::ClearRenderTarget(&amp;rendertarget);\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Functions/ClearRtv/","title":"ClearRtv","text":"<pre><code>extern int ClearRtv(ID3D11RenderTargetView* rtv);\n</code></pre> <p>Clears a d3d11 rendertarget.</p> <p>NOTE: This is a old function, use ClearRenderTarget instead if possible.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/CreateBackbuffer/","title":"CreateBackbuffer","text":"<pre><code>extern int CreateBackbuffer();\n</code></pre> <p>Creates the backbuffer used by the game.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/CreateBuffer/","title":"CreateBuffer","text":"<pre><code>extern int CreateBuffer(ID3D11Buffer** buffer, D3D11_BIND_FLAG bindFlag, void* data, int dataSize);\n</code></pre> <p>Simpel abstraction for creating buffers that are used by the GPU. Used for creating vertex and index buffers etc.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/CreateBuffer/#usage","title":"Usage","text":"<pre><code>ID3D11Buffer* vertexBuffer = NULL;\n\nVertex vert_array[4] = {};\nvert_array[0].pos = { -1.0f, -1.0f };\nvert_array[0].uv = { 0.0f, 1.0f };\nvert_array[1].pos = { -1.0f, 1.0f };\nvert_array[1].uv = { 0.0f, 0.0f };\nvert_array[2].pos = { 1.0f, 1.0f };\nvert_array[2].uv = { 1.0f, 0.0f };\nvert_array[3].pos = { 1.0f, -1.0f };\nvert_array[3].uv = { 1.0f, 1.0f };\nint vert_count = 4;\n\nif (D3DAPI::CreateBuffer(&amp;vertexBuffer, D3D11_BIND_VERTEX_BUFFER, vertex_array, sizeof(Vertex) * vertex_count))\n{\n    // Failed\n    return 1;\n}\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Functions/CreateConstantBuffer/","title":"CreateConstantBuffer","text":"<pre><code>extern int CreateConstantBuffer(void* data, int dataSize, OUT ConstantBuffer* constantBuffer);\n</code></pre> <p>Creates a constant buffer.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/CreateConstantBuffer/#usage","title":"Usage","text":"<pre><code>D3DAPI::ConstantBuffer framebuffer;\n\nD3DAPI::FrameCBuffer framebufferData = \n{\n    ...\n};\n\nD3DAPI::CreateConstantBuffer(&amp;framebufferData, sizeof(framebufferData), &amp;framebuffer);\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Functions/CreateDepthBuffer/","title":"CreateDepthBuffer","text":"<pre><code>extern int CreateDepthBuffer();\n</code></pre> <p>Creates the depthbuffer used alongside the backbuffer.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/CreateDeviceAndContext/","title":"CreateDeviceAndContext","text":"<pre><code>extern int CreateDeviceAndContext();\n</code></pre> <p>Creates the d3d11 device and device context.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/CreateFont/","title":"CreateFont","text":"<pre><code>extern void CreateFont(const char* path, OUT Font* font);\n</code></pre> <p>Creates a font. </p> <p>NOTE: Currently fonts are not standard TTFs or OTFs. We use BMFonts binary format for creating and storing fonts.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/CreateFont/#usage","title":"Usage","text":"<pre><code>D3DAPI::Font font;\nCreateFont(\"assets/fonts/arial.fnt\", &amp;font);\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Functions/CreateMaterial/","title":"CreateMaterial","text":"<pre><code>extern int CreateMaterial(Material* material, char* name, const char* colorPath = \"\", const char* normalPath = \"\", const char* material0Path = \"\", const char* material1Path = \"\");\n</code></pre> <p>Creates a material with the chosen textures.</p> <p>NOTE: Any textures that failed to be loaded will be substituted with a default texture in that slot. NOTE: Slot material1 is deprecated and will not be used.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/CreateMaterial/#usage","title":"Usage","text":"<pre><code>D3DAPI::Material material;\n\nD3DAPI::CreateMaterial(&amp;material, \"testMaterialName\", \"assets/testures/test_c.dds\", \"assets/testures/test_n.dds\", \"assets/testures/test_m.dds\");\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Functions/CreateMesh/","title":"CreateMesh","text":"<pre><code>extern int CreateMesh(Mesh* mesh, Vertex* vertexArray, int vertexCount, int* indexArray, int indexCount);\n</code></pre> <p>Creates a mesh.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/CreateMesh/#usage","title":"Usage","text":"<pre><code>D3DAPI::Mesh mesh;\n\nVertex vert_array[4] = {};\nvert_array[0].pos = { -1.0f, -1.0f };\nvert_array[0].uv = { 0.0f, 1.0f };\nvert_array[1].pos = { -1.0f, 1.0f };\nvert_array[1].uv = { 0.0f, 0.0f };\nvert_array[2].pos = { 1.0f, 1.0f };\nvert_array[2].uv = { 1.0f, 0.0f };\nvert_array[3].pos = { 1.0f, -1.0f };\nvert_array[3].uv = { 1.0f, 1.0f };\nint vert_count = 4;\n\nint index_array[6] =\n{\n\u00a0 \u00a0 0, 1, 2,\n\u00a0 \u00a0 0, 2, 3\n};\nint index_count = 6;\n\nif (CreateMesh(&amp;mesh, vert_array, vert_count, index_array, index_count))\n{\n    // Failed\n    return 1;\n}\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Functions/CreateRasterizerstate/","title":"CreateRasterizerstate","text":"<pre><code>extern int CreateRasterizerstate();\n</code></pre> <p>Creates all of the different rasterizer states.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/CreateRenderTarget/","title":"CreateRenderTarget","text":"<pre><code>extern int CreateRenderTarget(int width, int height, OUT RenderTarget* renderTarget);\n</code></pre> <p>Creates a RenderTarget.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/CreateRenderTarget/#usage","title":"Usage","text":"<pre><code>D3DAPI::RenderTarget rendertarget = {};\nD3DAPI::CreateRenderTarget(800, 600, &amp;rendertarget);\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Functions/CreateSamplerState/","title":"CreateSamplerState","text":"<pre><code>extern int CreateSamplerState(OUT Sampler* sampler, D3D11_FILTER filter = D3D11_FILTER_ANISOTROPIC);\n</code></pre> <p>Creates a sampler state.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/CreateSamplerState/#usage","title":"Usage","text":"<pre><code>D3DAPI::Sampler sampler;\n\nD3DAPI::CreateSamplerState(&amp;sampler);\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Functions/CreateShader/","title":"CreateShader","text":"<pre><code>extern int CreateShader(const char* vshaderPath, const char* pshaderPath, D3D11_INPUT_ELEMENT_DESC* inputDescArray, int inputDescCount, OUT Shader* shader);\n</code></pre> <p>Creates a shader.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/CreateShader/#usage","title":"Usage","text":"<pre><code>D3DAPI::Shader shader = {};\n\nD3DAPI::CreateShader(\"shaders/main_vs.cso\", \"shaders/main_ps.cso\", D3DAPI::defaultInputDescArray, D3DAPI::defaultInputDescArrayCount, &amp;shader);\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Functions/CreateSprite/","title":"CreateSprite","text":"<pre><code>extern int CreateSprite(const char* path, Vector2 pos, Vector2 size, Vector4 color, OUT Sprite* sprite);\n</code></pre> <p>Creates a sprite.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/CreateSprite/#usage","title":"Usage","text":"<pre><code>D3DAPI::Sprite sprite;\n\nD3DAPI::CreateSprite(\"assets/sprites/test.dds\", { 400.0f, 400.0f }, { 200.0f, 200.0f }, { 1.0f, 1.0f, 1.0f, 1.0f }, &amp;sprite);\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Functions/CreateSwapchain/","title":"CreateSwapchain","text":"<pre><code>extern int CreateSwapchain();\n</code></pre> <p>Creates the d3d11 swapchain.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/CreateTexture/","title":"CreateTexture","text":"<pre><code>extern int CreateTexture(float* bitmap, int width, int height, OUT Texture* texture);\n</code></pre> <p>Creates a texture from a bitmap.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/CreateTexture/#note-not-implemented","title":"NOTE: NOT IMPLEMENTED","text":""},{"location":"API%20Reference/D3D11%20API/Functions/DebugDrawRect/","title":"DebugDrawRect","text":"<pre><code>extern void DebugDrawRect(Vector2 pos, Vector2 size, Vector4 color);\n</code></pre> <p>Draws a simple rectangle on screen for debugging.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/DebugDrawRect/#usage","title":"Usage","text":"<pre><code>D3DAPI::DebugDrawRect({ 400.0f, 400.0f }, { 200.0f, 200.0f }, { 1.0f, 1.0f, 1.0f, 1.0f });\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Functions/DrawFont/","title":"DrawFont","text":"<pre><code>extern void DrawFont(const char* text, Font* font, Vector2 pos, float size, Vector4 color);\n</code></pre> <p>Draws some text with a specified font.</p> <p>NOTE: I believe this function is in screen space.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/DrawFont/#usage","title":"Usage","text":"<pre><code>D3DAPI::Font font;\nCreateFont(\"assets/fonts/arial.fnt\", &amp;font);\n\n...\n\nDrawFont(\"Test Text\", &amp;font, { 0.5f, 0.5f }, 1.0f, { 1.0f, 1.0f, 1.0f, 1.0f });\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Functions/DrawLine/","title":"DrawLine","text":"<pre><code>extern int DrawLine(Vector3 start, Vector3 end, Vector4 color);\n</code></pre> <p>Draws a single line</p>"},{"location":"API%20Reference/D3D11%20API/Functions/DrawLine/#usage","title":"Usage","text":"<pre><code>D3DAPI::DrawLine({ 0.0f, 0.0f, 0.0f }, { 0.0f, 1.0f, 0.0f }, { 0.0f, 0.0f, 1.0f, 1.0f });\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Functions/DrawLineArray/","title":"DrawLineArray","text":"<pre><code>extern int DrawLineArray(Line* lineArray, int lineCount);\n</code></pre> <p>Draws a array of lines.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/DrawLineArray/#usage","title":"Usage","text":"<pre><code>D3DAPI::Line lines[4];\nlines[0] = \n{\n    { 0.0f, 0.0f, 0.0f },\n    { 0.0f, 1.0f, 0.0f },\n    { 0.0f, 0.0f, 1.0f, 1.0f }\n};\nlines[1] = \n{\n    { 1.0f, 0.0f, 0.0f },\n    { 0.0f, 1.0f, 0.0f },\n    { 0.0f, 0.0f, 1.0f, 1.0f }\n};\nlines[2] = \n{\n    { 0.0f, 1.0f, 0.0f },\n    { 0.0f, 1.0f, 0.0f },\n    { 0.0f, 0.0f, 1.0f, 1.0f }\n};\nlines[3] = \n{\n    { 0.0f, 0.0f, 1.0f },\n    { 0.0f, 1.0f, 0.0f },\n    { 0.0f, 0.0f, 1.0f, 1.0f }\n};\n\nD3DAPI::DrawLineArray(lines, 4);\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Functions/DrawMesh/","title":"DrawMesh","text":"<pre><code>extern int DrawMesh(Mesh* mesh, Shader* shader);\n</code></pre> <p>Draws a mesh using a specified shader.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/DrawMesh/#usage","title":"Usage","text":"<pre><code>D3DAPI::Mesh mesh;\n// Create mesh with D3DAPI::CreateMesh\n\nD3DAPI::Shader shader;\n// Create shader with D3DAPI::CreateShader\n\n...\n\nD3DAPI::DrawMesh(&amp;mesh, &amp;shader);\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Functions/DrawMeshInstanced/","title":"DrawMeshInstanced","text":"<pre><code>extern int DrawMeshInstanced(Mesh* mesh, ID3D11Buffer* instanceBuffer, int instanceCount, Shader* shader);\n</code></pre> <p>Draws a mesh instanced.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/DrawMeshInstanced/#usage","title":"Usage","text":"<pre><code>D3DAPI::Mesh mesh;\n// Create mesh with D3DAPI::CreateMesh\nD3DAPI::Shader shader;\n// Create shader with D3DAPI::CreateShader\nID3D11Buffer* instanceBuffer;\n// Create instanceBuffer with D3DAPI::CreateBuffer\nint instanceCount = 6;\n\nD3DAPI::DrawMeshInstanced(&amp;mesh, instanceBuffer, instanceCount, &amp;shader);\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Functions/DrawModel/","title":"DrawModel","text":"<pre><code>extern int DrawModel(Model* model, Shader* shader, Material** material_array, int material_count);\n</code></pre> <p>Draws a model.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/DrawModel/#usage","title":"Usage","text":"<pre><code>D3DAPI::Model model;\n// Create model with D3DAPI::LoadModel\nD3DAPI::Shader shader;\n// Create shader with D3DAPI::CreateShader\nD3DAPI::Material* materialArray;\nint materialArrayCount;\n// Create material array with D3DAPI::CreateMaterial\n\n...\n\nD3DAPI::DrawModel(&amp;model, &amp;shader, &amp;materialArray, materialArrayCount);\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Functions/DrawModelInstanced/","title":"DrawModelInstanced","text":"<pre><code>extern int DrawModelInstanced(Model* model, Instance* instanceArray, int instanceCount, Shader* shader, Material** material_array, int material_count);\n</code></pre> <p>Draws a model instanced.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/DrawModelInstanced/#usage","title":"Usage","text":"<p>See DrawModel but this has two extra parameters for the instance data.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/DrawQuadResolutionSpace/","title":"DrawQuadResolutionSpace","text":"<pre><code>extern int DrawQuadResolutionSpace(Vector2 pos, Vector2 size, Vector4 color, Vector2 origin, Vector2 uvMin, Vector2 uvMax, OPTIONAL Shader* customShader);\n</code></pre> <p>Draws a quad in resolution space.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/DrawQuadResolutionSpace/#usage","title":"Usage","text":"<p>See DrawQuadScreenSpace but use resolution space units instead of screen space.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/DrawQuadResolutionWorldSpace/","title":"DrawQuadResolutionWorldSpace","text":"<pre><code>extern int DrawQuadResolutionWorldSpace(Vector2 pos, Vector2 size, Vector4 color, Vector2 origin, Vector2 uvMin, Vector2 uvMax, OPTIONAL Shader* customShader);\n</code></pre> <p>Draws a quad in resolution world space.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/DrawQuadResolutionWorldSpace/#usage","title":"Usage","text":"<p>See DrawQuadResolutionSpace but it's offset from the camera.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/DrawQuadScreenSpace/","title":"DrawQuadScreenSpace","text":"<pre><code>extern int DrawQuadScreenSpace(Vector2 pos, Vector2 size, Vector4 color, Vector2 origin, Vector2 uvMin, Vector2 uvMax, OPTIONAL Shader* customShader);\n</code></pre> <p>Draws a quad in screenspace.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/DrawQuadScreenSpace/#usage","title":"Usage","text":"<pre><code>DrawQuadScreenSpace({ 0.5f, 0.5f }, { 0.2f, 0.2f }, { 1.0f, 1.0f, 1.0f, 1.0f }, { 0.5f, 0.5f }, { 0.0f, 0.0f }, { 1.0f, 1.0f }, NULL);\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Functions/DrawRenderTargetToBackbuffer/","title":"DrawRenderTargetToBackbuffer","text":"<pre><code>extern int DrawRenderTargetToBackbuffer(RenderTarget* renderTarget);\n</code></pre> <p>Draws the current rendertarget to the backbuffer.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/DrawRenderTargetToBackbuffer/#usage","title":"Usage","text":"<pre><code>D3DAPI::RenderTarget rendertarget;\nD3DAPI::CreateRenderTarget(800, 600, &amp;rendertarget);\n\n...\n\nD3DAPI::DrawRenderTargetToBackbuffer(&amp;rendertarget);\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Functions/DrawSpriteResolutionSpace/","title":"DrawSpriteResolutionSpace","text":"<pre><code>extern int DrawSpriteResolutionSpace(Sprite* sprite);\n</code></pre> <p>Draws a sprite in resolution space.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/DrawSpriteResolutionSpace/#usage","title":"Usage","text":"<p>See DrawSpriteResolutionWorldSpace but this function draws it in regular resolution space.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/DrawSpriteResolutionWorldSpace/","title":"DrawSpriteResolutionWorldSpace","text":"<pre><code>extern int DrawSpriteResolutionWorldSpace(Sprite* sprite);\n</code></pre> <p>Draws a sprite in resolution world space</p>"},{"location":"API%20Reference/D3D11%20API/Functions/DrawSpriteResolutionWorldSpace/#usage","title":"Usage","text":"<pre><code>D3DAPI::Sprite sprite;\nD3DAPI::CreateSprite(\"assets/sprites/test.dds\", { 400.0f, 400.0f }, { 200.0f, 200.0f }, { 1.0f, 1.0f, 1.0f, 1.0f }, &amp;sprite);\n\nD3DAPI::DrawSpriteResolutionWorldSpace(&amp;sprite);\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Functions/GetBlendState/","title":"GetBlendState","text":"<pre><code>extern BLENDSTATE GetBlendState();\n</code></pre> <p>Gets the current blendstate.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/GetBlendState/#usage","title":"Usage","text":"<pre><code>D3DAPI::BLENDSTATE blendstate = D3DAPI::GetBlendState();\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Functions/Init/","title":"Init","text":"<pre><code>extern int Init();\n</code></pre> <p>Initializes the D3D11 API.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/LoadModel/","title":"LoadModel","text":"<pre><code>extern int LoadModel(Model* model, const char* path);\n</code></pre> <p>Loads a model.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/LoadModel/#usage","title":"Usage","text":"<pre><code>D3DAPI::Model model;\n\nD3DAPI::LoadModel(&amp;model, \"assets/models/test.fbx\");\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Functions/LoadTexture/","title":"LoadTexture","text":"<pre><code>extern int LoadTexture(const char* path, OUT Texture* texture);\n</code></pre> <p>Loads a texture from a given path.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/LoadTexture/#usage","title":"Usage","text":"<pre><code>D3DAPI::Texture texture;\n\nD3DAPI::LoadTexture(\"assets/sprites/testsprite.dds\", &amp;texture);\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Functions/Present/","title":"Present","text":"<pre><code>extern int Present(int vsync);\n</code></pre> <p>Presents the frame.</p> <p>NOTE: vsync can equal 0 through 4.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/Present/#usage","title":"Usage","text":"<pre><code>Present(0); // Presents with no vsync.\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Functions/RemovePointLight/","title":"RemovePointLight","text":"<pre><code>extern int RemovePointLight(int index);\n</code></pre> <p>Removes pointlight.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/RemovePointLight/#usage","title":"Usage","text":"<pre><code>D3DAPI::PointLight pointlight;\nint index = D3DAPI::AddPointLight(&amp;pointlight);\n\n...\n\nD3DAPI::RemovePointlight(index);\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Functions/RemoveSpotLight/","title":"RemoveSpotLight","text":"<pre><code>extern int RemoveSpotLight(int index);\n</code></pre> <p>Removes spotlight.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/RemoveSpotLight/#usage","title":"Usage","text":"<pre><code>D3DAPI::SpotLight spotlight;\nint index = D3DAPI::AddSpotLight(&amp;spotlight);\n\n...\n\nD3DAPI::RemoveSpotlight(index);\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Functions/Render/","title":"Render","text":"<pre><code>extern int Render(Mesh* mesh, Shader* shader, D3D11_PRIMITIVE_TOPOLOGY topologyType = D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);\n</code></pre> <p>Draws a mesh. No clue what the difference is between this and DrawMesh other than the extra optional topology type. Use DrawMesh unless you specifically need to specify topology type. </p>"},{"location":"API%20Reference/D3D11%20API/Functions/Render/#usage","title":"Usage","text":"<p>See DrawMesh but with an extra optional argument.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/ResizeBackbuffer/","title":"ResizeBackbuffer","text":"<pre><code>extern int ResizeBackbuffer(int width, int height);\n</code></pre> <p>Resizes the backbuffer.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/ResizeBackbuffer/#usage","title":"Usage","text":"<pre><code>int wantedX = 800;\nint wantedY = 600;\n\nif(D3DAPI::ResizeBackbuffer(wantedX, wantedY))\n{\n    // Failed\n    exit(1);\n}\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Functions/ResizeRenderTarget/","title":"ResizeRenderTarget","text":"<pre><code>extern int ResizeRenderTarget(RenderTarget* renderTarget, int width, int height);\n</code></pre> <p>Resizes a rendertarget.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/ResizeRenderTarget/#usage","title":"Usage","text":"<pre><code>D3DAPI::RenderTarget rendertarget;\nD3DAPI::CreateRenderTarget(800, 600, &amp;rendertarget);\n\n...\n\nD3DAPI::ResizeRenderTarget(&amp;rendertarget, 1920, 1080);\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Functions/SetAmbientLight/","title":"SetAmbientLight","text":"<pre><code>extern int SetAmbientLight(Vector4 ambientLight);\n</code></pre> <p>Sets ambient light.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/SetAmbientLight/#usage","title":"Usage","text":"<pre><code>D3DAPI::SetAmbientLight({ 0.2f, 0.2f, 0.2f, 1.0f });\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Functions/SetBackbufferAsRenderTarget/","title":"SetBackbufferAsRenderTarget","text":"<pre><code>extern int SetBackbufferAsRenderTarget(bool withDepth = true);\n</code></pre> <p>Sets the current rendertarget to be the backbuffer.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/SetBlendState/","title":"SetBlendState","text":"<pre><code>extern int SetBlendState(BLENDSTATE blendState, Color blendFactor = { 0.0f, 0.0f, 0.0f, 0.0f }, unsigned int sampleMask = 0xffffffff);\n</code></pre> <p>Sets the blendstate.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/SetBlendState/#usage","title":"Usage","text":"<pre><code>D3DAPI::SetBlendState(BLENDSTATE_OPAQUE);\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Functions/SetConstantBuffer/","title":"SetConstantBuffer","text":"<pre><code>extern int SetConstantBuffer(int slot, ConstantBuffer* constantBuffer);\n</code></pre> <p>Sets the constantbuffer on a slot for usage in a shader.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/SetConstantBuffer/#usage","title":"Usage","text":"<pre><code>D3DAPI::ConstantBuffer constantbuffer;\n// Create constantbuffer with D3DAPI::CreateConstantBuffer\n\nSetConstantBuffer(0, &amp;constantbuffer);0\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Functions/SetDirectionalLight/","title":"SetDirectionalLight","text":"<pre><code>extern int SetDirectionalLight(DirectionalLight* directionalLight);\n</code></pre> <p>Sets directional light.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/SetDirectionalLight/#usage","title":"Usage","text":"<pre><code>D3DAPI::DirectionalLight directionallight;\n// Init the directionallight with required data\n\nD3DAPI::SetDirectionalLight(&amp;directionallight);\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Functions/SetMaterial/","title":"SetMaterial","text":"<pre><code>extern int SetMaterial(Material* material);\n</code></pre> <p>Sets a material for usage by a shader.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/SetMaterial/#usage","title":"Usage","text":"<pre><code>D3DAPI::Material material;\nD3DAPI::CreateMaterial(&amp;material, \"testMaterialName\", \"assets/testures/test_c.dds\", \"assets/testures/test_n.dds\", \"assets/testures/test_m.dds\");\n\n...\n\nD3DAPI::SetMaterial(&amp;material);\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Functions/SetRenderTarget/","title":"SetRenderTarget","text":"<pre><code>extern int SetRenderTarget(RenderTarget* renderTarget, bool withDepth = true);\n</code></pre> <p>Sets the rendertarget along side a optional depthbuffer which is enabled by default.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/SetRenderTarget/#usage","title":"Usage","text":"<pre><code>D3DAPI::RenderTarget rendertarget;\nD3DAPI::CreateRenderTarget(800, 600, &amp;rendertarget);\n\n...\n\nD3DAPI::SetRenderTarget(&amp;rendertarget);\n// OR\nD3DAPI::SetRenderTarget(&amp;rendertarget, false);\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Functions/SetRtv/","title":"SetRtv","text":"<pre><code>extern int SetRtv(ID3D11RenderTargetView* rtv, OPTIONAL ID3D11DepthStencilView* dsv = NULL);\n</code></pre> <p>Sets a d3d11 rendertarget to be used for drawing.</p> <p>NOTE: This is a old function, use SetRenderTarget instead if possible.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/SetSamplerState/","title":"SetSamplerState","text":"<pre><code>extern int SetSamplerState(int slot, Sampler* sampler);\n</code></pre> <p>Sets the sampler on a specified slot.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/SetSamplerState/#usage","title":"Usage","text":"<pre><code>D3DAPI::Sampler sampler;\nD3DAPI::CreateSamplerState(&amp;sampler);\n\nD3DAPI::SetSamplerState(0, &amp;sampler);\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Functions/SetShader/","title":"SetShader","text":"<pre><code>extern int SetShader(Shader* shader);\n</code></pre> <p>Sets the shader to be used by the GPU.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/SetShader/#usage","title":"Usage","text":"<pre><code>D3DAPI::Shader shader = {};\nD3DAPI::CreateShader(\"shaders/main_vs.cso\", \"shaders/main_ps.cso\", globalInputDescArray, globalInputDescArrayCount, &amp;shader);\n\n...\n\nD3DAPI::SetShader(&amp;shader);\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Functions/SetTexture/","title":"SetTexture","text":"<pre><code>extern int SetTexture(int slot, Texture* texture);\n</code></pre> <p>Sets a texture on a slot for usage by a shader.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/SetTexture/#usage","title":"Usage","text":"<pre><code>D3DAPI::Texture texture;\nD3DAPI::LoadTexture(\"assets/sprites/testsprite.dds\", &amp;texture);\n\n...\n\nD3DAPI::SetTexture(0, &amp;texture);\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Functions/UnsetRenderTarget/","title":"UnsetRenderTarget","text":"<pre><code>extern int UnsetRenderTarget();\n</code></pre> <p>Unsets all rendertargets.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/UnsetRenderTarget/#usage","title":"Usage","text":"<pre><code>D3DAPI::RenderTarget rendertarget;\nD3DAPI::CreateRenderTarget(800, 600, &amp;rendertarget);\nD3DAPI::SetRenderTarget(&amp;rendertarget);\n\n...\n\nD3DAPI::UnsetRenderTarget();\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Functions/UnsetTexture/","title":"UnsetTexture","text":"<pre><code>extern int UnsetTexture(int slot);\n</code></pre> <p>Unset a texture on the specified slot.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/UnsetTexture/#usage","title":"Usage","text":"<pre><code>D3DAPI::Texture texture;\nD3DAPI::LoadTexture(\"assets/sprites/testsprite.dds\", &amp;texture);\nD3DAPI::SetTexture(0, &amp;texture);\n\n...\n\nD3DAPI::UnsetTexture(0);\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Functions/Update/","title":"Update","text":"<pre><code>extern int Update(float deltaTime);\n</code></pre> <p>Updates the D3D11 API.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/UpdateConstantBuffer/","title":"UpdateConstantBuffer","text":"<pre><code>extern int UpdateConstantBuffer(void* data, ConstantBuffer* constantBuffer);\n</code></pre> <p>Updates an existing constantbuffer.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/UpdateConstantBuffer/#usage","title":"Usage","text":"<pre><code>D3DAPI::ConstantBuffer framebuffer;\n// Create the constantbuffer with D3DAPI::CreateConstantBuffer\n\nD3DAPI::FrameCBuffer framebufferData = \n{\n    ...\n};\nD3DAPI::UpdateConstantBuffer(&amp;framebufferData, &amp;framebuffer);\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Functions/UpdateFreeLookCamera/","title":"UpdateFreeLookCamera","text":"<pre><code>extern void UpdateFreeLookCamera(float deltaTime);\n</code></pre> <p>Updates the engines freelook camera.</p>"},{"location":"API%20Reference/D3D11%20API/Functions/UpdateFreeLookCamera/#usage","title":"Usage","text":"<pre><code>UpdateFreeLookCamera(deltaTime);\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Structures/AnimationCBuffer/","title":"AnimationCBuffer","text":"<pre><code>ALIGN(16) typedef struct\n{\n\u00a0 \u00a0 Matrix bones[MAX_BONES_PER_MESH];\n} AnimationCBuffer;\n</code></pre> <p>Used for passing the animation-data to the shaders.</p>"},{"location":"API%20Reference/D3D11%20API/Structures/Bone/","title":"Bone","text":"<pre><code>typedef struct\n{\n\u00a0 \u00a0 char name[64]; // Max bone name length is 64\n\u00a0 \u00a0 Matrix offset;\n\u00a0 \u00a0 Matrix transform;\n} Bone;\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Structures/Camera/","title":"Camera","text":"<pre><code>typedef struct\n{\n\u00a0 \u00a0 Vector2 pos;\n} Camera;\n</code></pre> <p>Defines the 2D camera.</p>"},{"location":"API%20Reference/D3D11%20API/Structures/ConstantBuffer/","title":"ConstantBuffer","text":"<pre><code>typedef struct\n{\n\u00a0 \u00a0 ID3D11Buffer* buffer;\n\u00a0 \u00a0 int size;\n} ConstantBuffer;\n</code></pre> <p>Defines the constantbuffer abstraction.</p>"},{"location":"API%20Reference/D3D11%20API/Structures/ConstantBuffer/#associated-functions","title":"Associated functions","text":"<p>CreateConstantBuffer UpdateConstantBuffer SetConstantBuffer</p>"},{"location":"API%20Reference/D3D11%20API/Structures/DirectionalLight/","title":"DirectionalLight","text":"<pre><code>typedef struct\n{\n\u00a0 \u00a0 Vector4 direction;\n\u00a0 \u00a0 Vector4 color;\n} DirectionalLight;\n</code></pre> <p>Defines a directionallight.</p>"},{"location":"API%20Reference/D3D11%20API/Structures/DirectionalLight/#associated-functions","title":"Associated functions","text":"<p>SetDirectionalLight ClearLights</p>"},{"location":"API%20Reference/D3D11%20API/Structures/Font/","title":"Font","text":"<pre><code>typedef struct\n{\n\u00a0 \u00a0 FontInfo info;\n\u00a0 \u00a0 FontCharInfo characters[256];\n\u00a0 \u00a0 FontKerningInfo kerning_pairs[256];\n\u00a0 \u00a0 Texture texture_array[4];\n\u00a0 \u00a0 int texture_array_count;\n} Font;\n</code></pre> <p>Defines the font abstraction.</p>"},{"location":"API%20Reference/D3D11%20API/Structures/Font/#associated-functions","title":"Associated functions","text":"<p>CreateFont DrawFont</p>"},{"location":"API%20Reference/D3D11%20API/Structures/FontCharInfo/","title":"FontCharInfo","text":"<pre><code>typedef struct\n{\n\u00a0 \u00a0 int id;\n\u00a0 \u00a0 int x;\n\u00a0 \u00a0 int y;\n\u00a0 \u00a0 int width;\n\u00a0 \u00a0 int height;\n\u00a0 \u00a0 int xOffset;\n\u00a0 \u00a0 int yOffset;\n\u00a0 \u00a0 int xAdvance;\n\u00a0 \u00a0 int page;\n\u00a0 \u00a0 int channel;\n} FontCharInfo;\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Structures/FontInfo/","title":"FontInfo","text":"<pre><code>typedef struct\n{\n\u00a0 \u00a0 int size;\n\u00a0 \u00a0 int lineHeight;\n\u00a0 \u00a0 int base;\n\u00a0 \u00a0 int scaleWidth;\n\u00a0 \u00a0 int scaleHeight;\n} FontInfo;\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Structures/FontKerningInfo/","title":"FontKerningInfo","text":"<pre><code>typedef struct\n{\n\u00a0 \u00a0 FontKerningPair pairs[32];\n\u00a0 \u00a0 int pairs_count;\n} FontKerningInfo;\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Structures/FontKerningPair/","title":"FontKerningPair","text":"<pre><code>typedef struct\n{\n\u00a0 \u00a0 char first;\n\u00a0 \u00a0 char second;\n\u00a0 \u00a0 int amount;\n} FontKerningPair;\n</code></pre>"},{"location":"API%20Reference/D3D11%20API/Structures/FrameCBuffer/","title":"FrameCBuffer","text":"<pre><code>namespace D3DAPI\n{\n\u00a0 \u00a0 ALIGN(16) typedef struct\n\u00a0 \u00a0 {\n\u00a0 \u00a0 \u00a0 \u00a0 Matrix worldToClip;\n\u00a0 \u00a0 \u00a0 \u00a0 Vector3 cameraPos;\n\u00a0 \u00a0 \u00a0 \u00a0 float time;\n\u00a0 \u00a0 \u00a0 \u00a0 int selectedBone;\n\u00a0 \u00a0 \u00a0 \u00a0 Vector2 resolution;\n\u00a0 \u00a0 \u00a0 \u00a0 int pad3;\n\u00a0 \u00a0 } FrameCBuffer;\n}\n</code></pre> <p>This is used for passing through frame-data to the shaders.</p>"},{"location":"API%20Reference/D3D11%20API/Structures/Instance/","title":"Instance","text":"<pre><code>typedef struct\n{\n\u00a0 \u00a0 Matrix modelToWorld;\n\u00a0 \u00a0 unsigned int objectId;\n} Instance;\n</code></pre> <p>Contains the data for each instance of an instance drawn object.</p>"},{"location":"API%20Reference/D3D11%20API/Structures/LightCBuffer/","title":"LightCBuffer","text":"<pre><code>ALIGN(16) typedef struct\n{\n\u00a0 \u00a0 SpotLight spot_lights[MAX_SPOT_LIGHTS];\n\u00a0 \u00a0 PointLight point_lights[MAX_POINT_LIGHTS];\n\u00a0 \u00a0 int num_point_lights;\n\u00a0 \u00a0 int num_spot_lights;\n\u00a0 \u00a0 int pad0;\n\u00a0 \u00a0 int pad1;\n\u00a0 \u00a0 DirectionalLight directional_light;\n\u00a0 \u00a0 Vector4 ambient_light;\n} LightCBuffer;\n</code></pre> <p>Used for passing light-data to shaders.</p>"},{"location":"API%20Reference/D3D11%20API/Structures/Line/","title":"Line","text":"<pre><code>typedef struct\n{\n\u00a0 \u00a0 Vector3 start;\n\u00a0 \u00a0 Vector3 end;\n\u00a0 \u00a0 Vector4 color;\n} Line;\n</code></pre> <p>Defines the line abstraction.</p>"},{"location":"API%20Reference/D3D11%20API/Structures/Line/#associated-functions","title":"Associated functions","text":"<p>DrawLineArray DrawLine</p>"},{"location":"API%20Reference/D3D11%20API/Structures/Material/","title":"Material","text":"<pre><code>typedef struct\n{\n\u00a0 \u00a0 char name[MAX_MATERIAL_NAME_LENGTH];\n\u00a0 \u00a0 //MAT_FLAGS flags;\n\u00a0 \u00a0 int flags; // MAT_FLAGS\n\u00a0 \u00a0 Texture diffuseTexture;\n\u00a0 \u00a0 Texture normalTexture;\n\u00a0 \u00a0 Texture material0Texture;\n\u00a0 \u00a0 Texture material1Texture;\n} Material;\n</code></pre> <p>Defines the material abstraction.</p>"},{"location":"API%20Reference/D3D11%20API/Structures/Material/#associated-functions","title":"Associated functions","text":"<p>CreateMaterial SetMaterial</p>"},{"location":"API%20Reference/D3D11%20API/Structures/Mesh/","title":"Mesh","text":"<pre><code>struct Mesh\n{\n\u00a0 \u00a0 ID3D11Buffer* vertexBuffer;\n\u00a0 \u00a0 ID3D11Buffer* indexBuffer;\n\u00a0 \u00a0 int indexCount;\n\u00a0 \u00a0 Matrix meshToWorld; // TODO(Eric): When a model struct is introduced, move the Matrix there.\n\u00a0 \u00a0 int materialIndex;\n\n\u00a0 \u00a0 int bone_count;\n\u00a0 \u00a0 Bone bones[MAX_BONES_PER_MESH];\n\n\u00a0 \u00a0 unsigned int objectId = UINT_MAX;\n};\n</code></pre> <p>Defines the mesh abstraction.</p>"},{"location":"API%20Reference/D3D11%20API/Structures/Mesh/#associated-functions","title":"Associated functions","text":"<p>CreateMesh DrawMesh DrawMeshInstanced Render</p>"},{"location":"API%20Reference/D3D11%20API/Structures/Model/","title":"Model","text":"<pre><code>struct Model\n{\n\u00a0 \u00a0 Mesh meshArray[MAX_MODEL_MESHES];\n\u00a0 \u00a0 int meshArrayCount;\n\u00a0 \u00a0 //Material materialArray[MAX_MODEL_MATERIALS];\n\u00a0 \u00a0 int materialArrayCount;\n\u00a0 \u00a0 Matrix modelToWorld;\n\n\u00a0 \u00a0 Vector3 boundingBoxMin; // Object space positions\n\u00a0 \u00a0 Vector3 boundingBoxMax;\n\n\u00a0 \u00a0 OPTIONAL unsigned int objectId = UINT_MAX;\n};\n</code></pre> <p>Defines the model abstraction.</p>"},{"location":"API%20Reference/D3D11%20API/Structures/Model/#associated-functions","title":"Associated functions","text":"<p>LoadModel DrawModel DrawModelInstanced</p>"},{"location":"API%20Reference/D3D11%20API/Structures/ObjectCBuffer/","title":"ObjectCBuffer","text":"<pre><code>ALIGN(16) typedef struct\n{\n\u00a0 \u00a0 Matrix modelToWorld;\n\u00a0 \u00a0 unsigned int objectId;\n\u00a0 \u00a0 unsigned int pad0;\n\u00a0 \u00a0 unsigned int pad1;\n\u00a0 \u00a0 unsigned int pad2;\n} ObjectCBuffer;\n</code></pre> <p>Used for passing object-data into to the shaders.</p> <p>NOTE: This is for non-instanced objects. Passing data through to the shaders for instanced objects has to be done through the Instance struct.</p>"},{"location":"API%20Reference/D3D11%20API/Structures/PointLight/","title":"PointLight","text":"<pre><code>typedef struct\n{\n\u00a0 \u00a0 Vector4 position;\n\u00a0 \u00a0 Vector4 color;\n\u00a0 \u00a0 float range;\n\u00a0 \u00a0 float pad0;\n\u00a0 \u00a0 float pad1;\n\u00a0 \u00a0 float pad2;\n} PointLight;\n</code></pre> <p>Defines a pointlight.</p>"},{"location":"API%20Reference/D3D11%20API/Structures/PointLight/#associated-functions","title":"Associated functions","text":"<p>AddPointLight RemovePointLight ClearLights</p>"},{"location":"API%20Reference/D3D11%20API/Structures/RenderTarget/","title":"RenderTarget","text":"<pre><code>typedef struct\n{\n\u00a0 \u00a0 ID3D11Texture2D* texture2d;\n\u00a0 \u00a0 ID3D11RenderTargetView* rtv;\n\u00a0 \u00a0 ID3D11ShaderResourceView* srv;\n\u00a0 \u00a0 ID3D11Texture2D* texture2dDepth;\n\u00a0 \u00a0 ID3D11DepthStencilView* dsv;\n\u00a0 \u00a0 int width, height;\n} RenderTarget;\n</code></pre> <p>Defines the rendertarget abstraction.</p>"},{"location":"API%20Reference/D3D11%20API/Structures/RenderTarget/#associated-functions","title":"Associated functions","text":"<p>CreateRenderTarget ResizeRenderTarget SetRenderTarget UnsetRenderTarget ClearRenderTarget DrawRenderTargetToBackbuffer</p>"},{"location":"API%20Reference/D3D11%20API/Structures/Sampler/","title":"Sampler","text":"<pre><code>typedef struct\n{\n\u00a0 \u00a0 ID3D11SamplerState* samplerState;\n} Sampler;\n</code></pre> <p>Defines the sample abstraction.</p>"},{"location":"API%20Reference/D3D11%20API/Structures/Sampler/#associated-functions","title":"Associated functions","text":"<p>CreateSamplerState SetSamplerState</p>"},{"location":"API%20Reference/D3D11%20API/Structures/Shader/","title":"Shader","text":"<pre><code>typedef struct\n{\n\u00a0 \u00a0 ID3D11InputLayout* layout;\n\u00a0 \u00a0 ID3D11VertexShader* vshader;\n\u00a0 \u00a0 ID3D11PixelShader* pshader;\n} Shader;\n</code></pre> <p>Defines the shader abstraction.</p>"},{"location":"API%20Reference/D3D11%20API/Structures/Shader/#associated-functions","title":"Associated functions","text":"<p>CreateShader SetShader</p>"},{"location":"API%20Reference/D3D11%20API/Structures/SpotLight/","title":"SpotLight","text":"<pre><code>typedef struct\n{\n\u00a0 \u00a0 Vector4 color;\n\u00a0 \u00a0 Vector4 position;\n\u00a0 \u00a0 Vector4 direction;\n\u00a0 \u00a0 float range;\n\u00a0 \u00a0 float outerAngle;\n\u00a0 \u00a0 float innerAngle;\n\u00a0 \u00a0 float pad0;\n} SpotLight;\n</code></pre> <p>Defines a spotlight.</p>"},{"location":"API%20Reference/D3D11%20API/Structures/SpotLight/#associated-functions","title":"Associated functions","text":"<p>AddSpotLight RemoveSpotLight ClearLights</p>"},{"location":"API%20Reference/D3D11%20API/Structures/Sprite/","title":"Sprite","text":"<pre><code>typedef struct\n{\n\u00a0 \u00a0 Texture texture;\n\u00a0 \u00a0 Vector2 pos;\n\u00a0 \u00a0 Vector2 size;\n\u00a0 \u00a0 Vector4 color;\n\u00a0 \u00a0 //Vector2 origin; // NOTE(Eric): This is always 0.5f, 0.5f\n\u00a0 \u00a0 //Vector2 uvMin; // NOTE(Eric): This is always 0.0f, 0.0f\n\u00a0 \u00a0 //Vector2 uvMax; // NOTE(Eric): This is always 1.0f, 1.0f\n} Sprite;\n</code></pre> <p>Defines the sprite abstraction.</p>"},{"location":"API%20Reference/D3D11%20API/Structures/Sprite/#associated-functions","title":"Associated functions","text":"<p>CreateSprite DrawSpriteResolutionWorldSpace DrawSpriteResolutionSpace</p>"},{"location":"API%20Reference/D3D11%20API/Structures/Texture/","title":"Texture","text":"<pre><code>typedef struct\n{\n\u00a0 \u00a0 ID3D11Texture2D* texture2d;\n\u00a0 \u00a0 ID3D11ShaderResourceView* srv;\n\u00a0 \u00a0 int width, height;\n\u00a0 \u00a0 char path[MAX_PATH];\n} Texture;\n</code></pre> <p>Defines the texture abstraction.</p>"},{"location":"API%20Reference/D3D11%20API/Structures/Texture/#associated-functions","title":"Associated functions","text":"<p>CreateTexture LoadTexture SetTexture UnsetTexture</p>"},{"location":"API%20Reference/D3D11%20API/Structures/Vertex/","title":"Vertex","text":"<pre><code>typedef struct\n{\n\u00a0 \u00a0 Vector4 color;\n\u00a0 \u00a0 Vector3 pos;\n\u00a0 \u00a0 Vector2 uv;\n\u00a0 \u00a0 Vector3 normal;\n\u00a0 \u00a0 Vector3 bitangent;\n\u00a0 \u00a0 Vector3 tangent;\n\u00a0 \u00a0 uint32_t bones[4]; // AI_LMW_MAX_WEIGHTS as defined in &lt;assimp/postprocess.h&gt;\n\u00a0 \u00a0 float weights[4];\n} Vertex;\n</code></pre> <p>This is the vertex structure that most meshes use.</p> <p>NOTE: weights have to be normalized</p>"},{"location":"API%20Reference/Physics/Internal/PhysXUtils/Defines/","title":"Defines","text":"<pre><code>#define TEMP_PX_RELEASE(x)        \\\n                 if(x != nullptr) \\\n                     x-&gt;release();\\\n                 x = nullptr      \n</code></pre>"},{"location":"API%20Reference/Physics/Internal/PhysXUtils/Functions/FromPhysXMatrix/","title":"FromPhysXMatrix","text":"<pre><code>Matrix FromPhysXMatrix(const physx::PxMat44&amp; aMatrix);\n</code></pre> <p>Converts PhysX Matrix to SimpleMath Matrix.</p>"},{"location":"API%20Reference/Physics/Internal/PhysXUtils/Functions/FromPhysXQuat/","title":"FromPhysXQuat","text":"<pre><code>Quaternion FromPhysXQuat(const physx::PxQuat&amp; aQuaternion);\n</code></pre> <p>Converts PhysX Quaternion to SimpleMath Quaternion.</p>"},{"location":"API%20Reference/Physics/Internal/PhysXUtils/Functions/FromPhysXTransform/","title":"FromPhysXTransform","text":"<pre><code>Matrix FromPhysXTransform(const physx::PxTransform&amp; aTransform);\n</code></pre> <p>Converts PhysX Transform to SimpleMath Matrix.</p>"},{"location":"API%20Reference/Physics/Internal/PhysXUtils/Functions/FromPhysXVector/","title":"FromPhysXVector","text":"<pre><code>    Vector3 FromPhysXVector(const physx::PxVec3&amp; aVector);\n    Vector4 FromPhysXVector(const physx::PxVec4&amp; aVector);\n</code></pre> <p>Converts PhysX Vector3/Vector4 to SimpleMath Vector3/Vector4.</p>"},{"location":"API%20Reference/Physics/Internal/PhysXUtils/Functions/ToPhysXMatrix/","title":"ToPhysXMatrix","text":"<pre><code>physx::PxMat44 ToPhysXMatrix(const Matrix&amp; aMatrix);\n</code></pre> <p>Converts SimpleMath Matrix to PhysX Matrix.</p>"},{"location":"API%20Reference/Physics/Internal/PhysXUtils/Functions/ToPhysXQuat/","title":"ToPhysXQuat","text":"<pre><code>physx::PxQuat ToPhysXQuat(const Quaternion&amp; aQuaterion);\n</code></pre> <p>Converts SimpleMath Quaternion to PhysX Quaternion.</p>"},{"location":"API%20Reference/Physics/Internal/PhysXUtils/Functions/ToPhysXTransform/","title":"ToPhysXTransform","text":"<pre><code>physx::PxTransform ToPhysXTransform(const Transform&amp; aTransform);\nphysx::PxTransform ToPhysXTransform(const Matrix&amp; aTransform);\nphysx::PxTransform ToPhysXTransform(const Vector3&amp; aTranslation, const Vector3&amp; aRotation);\n</code></pre> <p>Converts Engine Transform Component/Matrix/Translation &amp; Rotation to PhysX Transform.</p>"},{"location":"API%20Reference/Physics/Internal/PhysXUtils/Functions/ToPhysXTransform/#usage","title":"Usage","text":"<pre><code>//Functions that take physx transfrom \nphysx::PxPhysics::createRigidStatic( PhysXUtils::ToPhysXTransform( *myGameObject-&gt;GetComponent&lt;Transform&gt;() ) );\n</code></pre>"},{"location":"API%20Reference/Physics/Internal/PhysXUtils/Functions/ToPhysXVector/","title":"ToPhysXVector","text":"<pre><code>physx::PxVec3 ToPhysXVector(const Vector3&amp; aVector);\nphysx::PxVec4 ToPhysXVector(const Vector4&amp; aVector);\n</code></pre> <p>Converts SimpleMath Vector3/Vector4 to PhysX Vector3/Vector4.</p>"},{"location":"API%20Reference/Physics/PhysicsActor/Functions/AddForce/","title":"AddForce","text":"<pre><code>void AddForce(const Vector3&amp; aForce, ForceMode aForceMode = ForceMode::Force);\n</code></pre> <p>Adds force based on ForceMode to the actor, if not specified it will use Force.</p>"},{"location":"API%20Reference/Physics/PhysicsActor/Functions/AddTorque/","title":"AddTorque","text":"<pre><code>void AddTorque(const Vector3&amp; aTorque, ForceMode aForceMode = ForceMode::Force);\n</code></pre> <p>Adds torque based on ForceMode to the actor, if not specified it will use Force.</p>"},{"location":"API%20Reference/Physics/PhysicsActor/Functions/ClearForce/","title":"ClearForce","text":"<pre><code>void ClearForce( ForceMode aForceMode );\n</code></pre> <p>Clears actor's specified force.</p>"},{"location":"API%20Reference/Physics/PhysicsActor/Functions/ClearTorque/","title":"ClearTorque","text":"<pre><code>void ClearTorque( ForceMode aForceMode );\n</code></pre> <p>Clears actor's specified torque.</p>"},{"location":"API%20Reference/Physics/PhysicsActor/Functions/GetAngularVelocity/","title":"GetLinearVelocity","text":"<pre><code>Vector3 GetAngularVelocity() const;\n</code></pre> <p>Returns actor's angular(rotation) velocity.</p>"},{"location":"API%20Reference/Physics/PhysicsActor/Functions/GetGameObjectID/","title":"GetGameObjectID","text":"<pre><code>uint64_t GetGameObjectID() {return myGameObjectID;}\n</code></pre> <p>Returns GameObjectID associated with the actor</p>"},{"location":"API%20Reference/Physics/PhysicsActor/Functions/GetLinearVelocity/","title":"GetLinearVelocity","text":"<pre><code>Vector3 GetLinearVelocity() const;\n</code></pre> <p>Returns actor's linear(translation) velocity.</p>"},{"location":"API%20Reference/Physics/PhysicsActor/Functions/GetMass/","title":"GetMass","text":"<pre><code>float GetMass() const;\n</code></pre> <p>Returns the actor's mass.</p>"},{"location":"API%20Reference/Physics/PhysicsActor/Functions/GetPosition/","title":"GetPosition","text":"<pre><code>Vector3 GetPosition() {return PhysXUtils::FromPhysXVector(myInternalActor-&gt;getGlobalPose().p); }\n</code></pre> <p>Returns actor's globla position.</p>"},{"location":"API%20Reference/Physics/PhysicsActor/Functions/GetRotation/","title":"GetRotation","text":"<pre><code>Quaternion GetRotation() {return PhysXUtils::FromPhysXQuat(myInternalActor-&gt;getGlobalPose().q); }\n</code></pre> <p>Returns actor's globla rotation in quaternion.</p>"},{"location":"API%20Reference/Physics/PhysicsActor/Functions/IsDynamic/","title":"IsDynamic","text":"<pre><code>bool IsDynamic() const {return myRigidBody.GetBodyType() == RigidBodyComponent::Type::DYNAMIC; }\n</code></pre> <p>Gets if anctor rigidbody type is dynamic.</p>"},{"location":"API%20Reference/Physics/PhysicsActor/Functions/Rotate/","title":"Rotate","text":"<pre><code>void Rotate(const Vector3&amp; aRotation);\n</code></pre>"},{"location":"API%20Reference/Physics/PhysicsActor/Functions/Rotate/#paramter","title":"Paramter","text":"<p>aRotation - Rotation in radian</p> <p>Rotates the actor in world space,</p>"},{"location":"API%20Reference/Physics/PhysicsActor/Functions/SetAngularDrag/","title":"SetAngularDrag","text":"<pre><code>void SetAngularDrag(float aDrag) const;\n</code></pre> <p>Sets actor's angular(rotation) drag.</p>"},{"location":"API%20Reference/Physics/PhysicsActor/Functions/SetAngularVelocity/","title":"SetLinearVelocity","text":"<pre><code>void SetAngularVelocity(const Vector3&amp; aVelocity);\n</code></pre> <p>Sets actor's angular(rotation) velocity.</p>"},{"location":"API%20Reference/Physics/PhysicsActor/Functions/SetLinearDrag/","title":"SetLinearDrag","text":"<pre><code>void SetLinearDrag(float aDrag) const;\n</code></pre> <p>Sets actor's linear(translation) drag.</p>"},{"location":"API%20Reference/Physics/PhysicsActor/Functions/SetLinearVelocity/","title":"SetLinearVelocity","text":"<pre><code>void SetLinearVelocty(const Vector3&amp; aVelocity);\n</code></pre> <p>Sets actor's linear(translation) velocity.</p>"},{"location":"API%20Reference/Physics/PhysicsActor/Functions/SetMass/","title":"SetMass","text":"<pre><code>void SetMass(float aMass);\n</code></pre> <p>Sets the actor's mass.</p>"},{"location":"API%20Reference/Prefab%20Utility/Instantiate/","title":"Instatiate","text":"<pre><code>Engine::GameObject* Instantiate(const uint64_t aPrefabId, Engine::ObjectManager* aManager);\n</code></pre> <p>Will create a prefab in the scene using the UUID of the prefab</p>"},{"location":"API%20Reference/Prefab%20Utility/Instantiate/#usage","title":"Usage","text":"<pre><code>//Get the current scenes manager \nEngine::ObjectManager* manager = SceneManager::GetInstance()-&gt;GetActiveScene()-&gt;GetObjectManager();\n\nEngine::GameObject* newPrefab = Instantiate(aPrefabId, manager);\n</code></pre> <p>The prefab UUID can be fetched either from the the json file itself or from a existing gameobject</p> <pre><code>Engine::GameObject* prefabGameobject;\nprefabGameobject-&gt;GetPrefabId();\n</code></pre>"},{"location":"API%20Reference/Prefab%20Utility/Functions/CreatePrefab/","title":"CreatePrefab","text":"<pre><code>    void CreatePrefab(const uint64_t aGameObjectID, const std::wstring aRelativePath);\n</code></pre> <p>This will create a .prefab json file, its not used to create a prefab during runtime</p>"},{"location":"API%20Reference/Prefab%20Utility/Functions/CreatePrefab/#usage","title":"Usage","text":"<pre><code>//Gameobject to create prefab from\nEngine::Gameobject* object;\n\n//Path to create prefab json at\nstd::wstring path;\n\nCreatePrefab(object, path);\n</code></pre>"},{"location":"API%20Reference/Prefab%20Utility/Functions/Instantiate/","title":"Instatiate","text":"<pre><code>    Engine::GameObject* Instantiate(const uint64_t aPrefabId, Engine::ObjectManager* aManager);\n</code></pre> <p>Will create a prefab in the scene using the UUID of the prefab</p>"},{"location":"API%20Reference/Prefab%20Utility/Functions/Instantiate/#usage","title":"Usage","text":"<pre><code>//Get the current scenes manager \nEngine::ObjectManager* manager = SceneManager::GetInstance()-&gt;GetActiveScene()-&gt;GetObjectManager();\n\nEngine::GameObject* newPrefab = Instantiate(aPrefabId, manager);\n</code></pre> <p>The prefab UUID can be fetched either from the the json file itself or from a existing gameobject</p> <pre><code>Engine::GameObject* prefabGameobject;\nprefabGameobject-&gt;GetPrefabId();\n</code></pre>"},{"location":"API%20Reference/Prefab%20Utility/Functions/LoadAllPrefabs/","title":"LoadAllPrefabs","text":"<pre><code>void LoadAllPrefabs();\n</code></pre> <p>Load all prefab paths and UUIDs from the assets folder</p>"},{"location":"API%20Reference/Prefab%20Utility/Functions/Override/","title":"Override","text":"<pre><code>bool Override(const uint64_t aPrefabId);\n</code></pre> <p>This will override a existing .prefab file and all prefabs active in the scenes</p>"},{"location":"API%20Reference/Prefab%20Utility/Functions/Override/#usage","title":"Usage","text":"<pre><code>//Prefab object that will be overriden\nEngine::Gameobject* object;\n\n\nOverride(object-&gt;GetPrefabId());\n</code></pre>"},{"location":"API%20Reference/Prefab%20Utility/Functions/SaveChild/","title":"SaveChild","text":"<pre><code>void SaveChild(nlohmann::ordered_json&amp; outJson, Engine::GameObject* parentObject);\n</code></pre> <p>This will recusive save all children to the .prefab file</p>"},{"location":"API%20Reference/Renderer/Defines/","title":"Defines","text":"<pre><code>#define MAX_MODEL_ANIMATIONS 16\n</code></pre>"},{"location":"API%20Reference/Renderer/Enums/PP_TYPE/","title":"PP_TYPE","text":"<pre><code>enum BLENDSTATE {\n\u00a0 \u00a0 BLENDSTATE_NULL, BLENDSTATE_OPAQUE, BLENDSTATE_ALPHA, BLENDSTATE_ADDITIVE, BLENDSTATE_COUNT\n};\n</code></pre> <p>Indicates which blendstate to switch to or is currently active.</p>"},{"location":"API%20Reference/Renderer/Enums/PP_TYPE/#associated-functions","title":"Associated functions","text":"<p>AddPostProcess</p>"},{"location":"API%20Reference/Renderer/Enums/RENDER_MODE/","title":"RENDER_MODE","text":"<pre><code>enum BLENDSTATE {\n\u00a0 \u00a0 BLENDSTATE_NULL, BLENDSTATE_OPAQUE, BLENDSTATE_ALPHA, BLENDSTATE_ADDITIVE, BLENDSTATE_COUNT\n};\n</code></pre> <p>Indicates which blendstate to switch to or is currently active.</p>"},{"location":"API%20Reference/Renderer/Enums/RENDER_MODE/#associated-functions","title":"Associated functions","text":"<p>SetBlendState GetBlendState</p>"},{"location":"API%20Reference/Renderer/Structures/AnimationInstance/","title":"AnimationInstance","text":"<pre><code>struct AnimationInstance\n{\n    char path[260];\n    D3DAPI::Animation* animation;\n\n    float weight;\n\n    int currentFrame;\n    float time;\n    float speed;\n    bool playing;\n    bool looping;\n    bool done;\n    bool paused;\n\n    void Play(bool loop = false);\n    void Stop();\n    void Pause();\n    void Update(float deltaTime);\n};\n</code></pre> <p>Defines the instance of a animation. It contains a pointer to the actual animation and some other info used for updating the animation and selecting the current frame.</p>"},{"location":"API%20Reference/Renderer/Structures/AnimationInstance/#associated-functions","title":"Associated functions","text":""},{"location":"API%20Reference/Renderer/Structures/FlipBook/","title":"FlipBook","text":"<pre><code>struct FlipBook\n{\n    int numFrames;\n    float frameTime;\n\n    float time;\n    int currentFrame;\n\n    struct Frame\n    {\n        Vector2 uvOffsetMin;\n        Vector2 uvOffsetMax;\n    };\n    Frame* frames;\n};\n</code></pre> <p>Defines the FlipBook abstraction.</p>"},{"location":"API%20Reference/Renderer/Structures/FlipBook/#associated-functions","title":"Associated functions","text":""},{"location":"API%20Reference/Renderer/Structures/MaterialInstance/","title":"MaterialInstance","text":"<pre><code>struct MaterialInstance\n{\n    char name[MAX_MATERIAL_NAME_LENGTH];\n\n    char colorPath[MAX_PATH];\n    char normalPath[MAX_PATH];\n    char material0Path[MAX_PATH];\n    char material1Path[MAX_PATH];\n\n    D3DAPI::Material* material;\n};\n</code></pre> <p>Defines a instance of a material.</p>"},{"location":"API%20Reference/Renderer/Structures/MaterialInstance/#associated-functions","title":"Associated functions","text":""},{"location":"API%20Reference/Renderer/Structures/ModelInstance/","title":"ModelInstance","text":"<pre><code>struct ModelInstance \n{\n    _ModelInstance* modelInstance;\n    int* refCount;\n\n    ...(Constructors and other shit)\n}\n</code></pre> <p>This is the wrapper for _ModelInstance but this one is available for wider use. It is basically a reference counting smart pointer. Used to you don't manually need to call the AllocateModelInstance and FreeModelInstance.</p>"},{"location":"API%20Reference/Renderer/Structures/ModelInstance/#associated-functions","title":"Associated functions","text":""},{"location":"API%20Reference/Renderer/Structures/PostProcess/","title":"PostProcess","text":"<pre><code>typedef struct PostProcess\n{\n    D3DAPI::RenderTarget rendertarget;\n    PP_TYPE type;\n\n    PostProcessExecute execute;\n\n    union\n    {\n        struct\n        {\n            D3DAPI::Shader* shader_downsample;\n            D3DAPI::Shader* shader_upsample;\n            D3DAPI::Shader* shader_combine;\n\n            D3DAPI::RenderTarget* rendertargets[4];\n            D3DAPI::RenderTarget* shitRT;\n\n            D3DAPI::Sampler* pointSampler;\n            D3DAPI::Sampler* bilinearSampler;\n\n            D3DAPI::ConstantBuffer* constantBuffer;\n        } bloom;\n        struct\n        {\n            D3DAPI::Shader* shader;\n        } tonemap;\n        struct\n        {\n            D3DAPI::Shader* shader;\n        } vignette;\n        struct\n        {\n            D3DAPI::Shader* shader;\n        } color_grade;\n    };\n} PostProcess;\n</code></pre> <p>Defines the PostProcess abstraction.</p>"},{"location":"API%20Reference/Renderer/Structures/PostProcess/#associated-functions","title":"Associated functions","text":""},{"location":"API%20Reference/Renderer/Structures/PostProcessSystem/","title":"PostProcessSystem","text":"<pre><code>typedef struct\n{\n    D3DAPI::RenderTarget rendertargetSource;\n    PostProcess postProcesses[MAX_POST_PROCESSES];\n    int postProcessCount;\n} PostProcessSystem;\n</code></pre> <p>Defines the PostProcessSystem abstraction.</p>"},{"location":"API%20Reference/Renderer/Structures/PostProcessSystem/#associated-functions","title":"Associated functions","text":""},{"location":"API%20Reference/Renderer/Structures/_ModelInstance/","title":"_ModelInstance","text":"<pre><code>struct _ModelInstance\n{\n    char path[260];\n    D3DAPI::Model* model = nullptr;\n    D3DAPI::Shader* shader = nullptr;\n    Matrix modelToWorld;\n\n    MaterialInstance material[MAX_MODEL_MATERIALS];\n    int materialCount = 0;\n\n    bool transparent = false;\n\n    bool isAnimated;\n    AnimationInstance animations[MAX_MODEL_ANIMATIONS];\n    int animationCount;\n    void StopAllAnimations()\n    {\n        for (int i = 0; i &lt; animationCount; i++)\n        {\n            animations[i].Stop();\n        }\n    }\n\n    Vector2 uvOffsetMin = Vector2::Zero;\n    Vector2 uvOffsetMax = Vector2::One;\n    bool uvOffset = false;\n\n    FlipBook flipBook;\n\n    bool isSelected = false;\n\n    float normalExpand = 0.0f;\n\n    OPTIONAL unsigned int objectId = UINT_MAX;\n};\n</code></pre> <p>Defines the internal representation for a model instance. It is owned by the rendersystem and one can be allocated by using the AllocateModelInstance function and free'd with FreeModelInstance</p>"},{"location":"API%20Reference/Renderer/Structures/_ModelInstance/#associated-functions","title":"Associated functions","text":"<p>AllocateModelInstance FreeModelInstance</p>"},{"location":"Tutorials/BugsToFix/","title":"BugsToFix","text":"<p>Issues with Sprite Alpha</p> <p></p> <p>Issues with Sprite Size is not render correct</p> <p></p>"},{"location":"Tutorials/Metrics/","title":"Metrics","text":""},{"location":"Tutorials/NatdanaiTest/","title":"NatdanaiTest","text":""},{"location":"Tutorials/NatdanaiTest/#player-metrics","title":"Player Metrics","text":""},{"location":"Tutorials/NatdanaiTest/#test1","title":"test1","text":"<p>test test</p>"},{"location":"Tutorials/NatdanaiTest/#test12","title":"test12","text":""},{"location":"Tutorials/NatdanaiTest/#metrics2","title":"metrics2","text":""},{"location":"Tutorials/NatdanaiTest/#test2","title":"test2","text":"<p>test test test</p>"},{"location":"Tutorials/NatdanaiTest/#test3","title":"test3","text":"<p>lorem ipsum</p> <p></p> <ul> <li> <p>Player Metrics</p> </li> <li> <p>hi</p> </li> <li> <p>hi2</p> </li> </ul> <pre><code>int main()\n {\n    int* test = nullptr;\n    return 0\n }\n</code></pre>"},{"location":"Tutorials/Editor/Common/Common/","title":"Common Info","text":""},{"location":"Tutorials/Editor/Common/Common/#known-bugs","title":"Known Bugs","text":"<ul> <li>Save the scene file (.tmpscene) manually now and then because the scenes sometimes gets deleted.</li> </ul>"},{"location":"Tutorials/Editor/Controls/Camera/","title":"Camera controls","text":"<p>The editor has its own camera seperate from the game. This camera will be auto selected when pressing the stop button or when you first start the editor.</p> <p>Start by opening the editor window by pressing on the \"Editor\" tab.</p> <p>Once the editor window is open you can move the camera while holding the Right mouse button.</p> <p>After that you can use the following to move in the scene:</p> <ul> <li>Right Mouse Button - Look Around</li> <li>W - Forward</li> <li>A - Left</li> <li>S - Backwards</li> <li>D - Right</li> <li>Q - Down</li> <li>E - Up</li> <li>Shift - Boost</li> <li>Shift + Scroll up - Increase Boost Speed</li> <li>Shift + Scroll Down - Decrease Boost Speed</li> </ul>"},{"location":"Tutorials/Editor/Controls/Shortcut%20List/","title":"Key Shortcuts","text":"<ul> <li>F - To focus on a object in the scene window</li> <li>CTRL + S - Save current scene</li> </ul> <p>Guizmo Shortcut Camera Shortcut</p>"},{"location":"Tutorials/Editor/Hierarchy/Adding%20Objects/","title":"Adding Objects To Hierarchy","text":"<p>There are two main ways to add object to the editor hierarchy.</p> <p>The firts way is to use the add button on the top left corner of the hierarchy</p> <p></p> <p>The second way is to drag a FBX from the assets window</p> <p></p>"},{"location":"Tutorials/Editor/Materials/Material%20Editor/","title":"Creating A Material","text":"<p>To create a material, use the Material Editor window.</p> <p>Do the following to create a material:</p> <ol> <li>Open the Material Editor Window found here:</li> </ol> <p></p> <p>In the window there are a few things: </p> <ol> <li> <p>Starting from the top we find the name of the material. Here you can drag an existing material to edit or create a new one using the same textures.</p> </li> <li> <p>Then we have the texture slots. When a texture is dragged and added, it will display the name and show the texture next to it.</p> </li> <li> <p>At the bottom we have the create button. This button can be used to create the final material and store it at the desired location. At the moment its not recommended to delete a material after its been created, this because if the material is used on a model in any scene, the scene may not be able to load or crash.</p> </li> <li> <p>Beside the create button there's the clear button, this will clear the whole window including textures and material.</p> </li> <li> <p>The last button is the override button, if a existing material has been added to the window the override button can override the material and it will automatically update. Note that right now it wont update on a model until after the application has been restarted</p> </li> </ol> <p></p>"},{"location":"Tutorials/Editor/Materials/Material%20Editor/#drag-existing-material","title":"Drag Existing Material","text":""},{"location":"Tutorials/Editor/Materials/Material%20Editor/#drag-textures","title":"Drag Textures","text":""},{"location":"Tutorials/Editor/Prefabs/Common%20Info/","title":"Common Prefab Info","text":"<p>Common Info:</p> <ol> <li>There cannot be any \"Local\" changes to a prefab. For Example:</li> </ol> <p>If the prefab has a child and you move it on one prefab instance, when then saving the scene and reloading the scene it will return to its original position. This means that if a change is not overriden it wont saved. But the root object (the highest parent) will have a local transform that will be saved in the scene.</p> <p>Known problems:</p> <ol> <li>Prefabs sometimes dont override the first time.</li> <li>Prefab names with space in them sometimes cant be overriden at all.</li> <li>Prefabs wont get (1), (2), etc.... Instead they will just get the name.</li> </ol> <p>Future features:</p> <ol> <li>Change name through assets window</li> <li>Add (1), (2), etc.... To the name in the hierarchy</li> </ol>"},{"location":"Tutorials/Editor/Prefabs/Creation/","title":"Creating A Prefab","text":"<p>You can create a prefab by just draging it from the hierarchy to the assets window. The prefab will be created in the current directory you see in the assets window.</p> <p></p> <p>The prefab name will turn blue in the hierarchy and it will be added to the assets window. </p> <p></p>"},{"location":"Tutorials/Editor/Prefabs/Override/","title":"Overriding A Prefab","text":"<p>To override a prefab use the override button in the inspector after selecting the prefab.</p> <p></p> <p>After, it will ask if you are sure you want to override. If the override fails you will get a window saying it failed. When it fails try once more, if it keeps failing try making a new identical prefab. Last resort ask help.</p> <p></p>"},{"location":"Tutorials/Editor/Scene%20Window/Guizmo/","title":"Guizmo","text":"<p>In the Scene window you can change the guizmo modes (translate, rotate, scale) in two ways.</p> <p>The first way is to use the guizmo modes window found att the left side of the scene window. The modes are as followed:</p> <ol> <li>Translate (move)</li> <li>Rotate</li> <li>Scale</li> <li>Bound scaling</li> </ol> <p>The second way to change the modes are using the keyboard shortcuts. While not holding the right mouse button you can use:</p> <ul> <li>W - Translate</li> <li>E - Rotate</li> <li>R - Scale</li> <li>T - Bound scaling</li> </ul> <p>Note that you must have atleast one object selected to be able to use the keyboard shortcuts.</p>"},{"location":"Tutorials/Editor/Scene%20Window/Menu%20Bar/","title":"Menu Bar","text":"<p>In the top of the scene window there is a menu bar with a few options.</p> <p>The first option is changing between World and Local space on the guizmo.</p> <p>The second is Grid Snapping which has a few options:</p> <ol> <li>Snap - Enable/Disable the snapping (Can also be done with left CTRL)</li> <li>Lock Axis - This will lock so all axis will use the same snap value</li> <li>Show Grid - This will just enable/disable the grid</li> <li>Move - The X Y Z values for the snapping</li> <li>Rotate - The Rotation snapping value in Eular angles (0-360)</li> <li>Scale - The Scale snapping value </li> </ol> <p>The third option is Render Modes which makes it possible to change render modes. This can also be accessed from the Setting window</p>"},{"location":"Tutorials/Editor/Visual%20Scripting/Common/","title":"Setup","text":"<p>Setting up visual scripting</p> <ol> <li> <p>Open visual scripting tool window </p> </li> <li> <p>Create new script, and name it </p> </li> <li> <p>Press \"Save\" button to save script.</p> </li> <li>Start scripting.</li> </ol>"},{"location":"Tutorials/Editor/Visual%20Scripting/Common/#running-script-in-scene","title":"Running script in scene","text":"<ol> <li> <p>Add a \"ScriptingComponent\" to the object that is supposed to run script code. </p> </li> <li> <p>Choose a script to use on object.  </p> </li> <li> <p>Press play</p> </li> </ol>"},{"location":"Tutorials/Editor/Visual%20Scripting/Nodes/Nodes/","title":"Nodes","text":"<p>TODO: Add docs on nodes :) </p>"},{"location":"Tutorials/Renderer/How%20to%20play%20animations/","title":"How to play animations","text":"<p>The way animations work is that the _ModelInstance  struct has an array of AnimationInstance and a animation count. The renderer loops over these checking if any are playing and updating them and sending them to be used down the chain to DrawMesh.</p> <p>It is recommended that you have a enum of all the animations to be able to select them easier. Example: <pre><code>enum TestAnim\n{\n    TestAnim_One,\n    TestAnim_Two,\n    TestAnim_Count\n};\n\nRenderer::ModelInstance modelInstance = {};\n\nvoid InitModelInstance()\n{\n    modelInstance-&gt;animations[TestAnim_One] = Renderer::LoadAnimation(\"assets/Mesh/player/a_player_idle.fbx\", modelInstance);\n    modelInstance-&gt;animations[TestAnim_Two] = Renderer::LoadAnimation(\"assets/Mesh/player/a_player_run.fbx\", modelInstance);\n    modelInstance-&gt;animationCount = TestAnim_Count;\n}\n</code></pre></p> <p>Then in order to play one of the animations you just call that AnimationInstance's Play method. <pre><code>modelInstance-&gt;animations[TestAnim_One].Play();\n//modelInstance-&gt;animations[TestAnim_One].Play(true); // Loop\n</code></pre></p> <p>You can prematurely stop an animation before it's finished by calling it's Stop function. Example: <pre><code>modelInstance-&gt;animations[TestAnim_One].Stop();\n</code></pre></p> <p>Or you can stop all animations on a _ModelInstance by calling it's StopAllAnimations method. <pre><code>modelInstance-&gt;StopAllAnimations();\n</code></pre></p> <p>You can lower the influence an animation has on the _ModelInstance by adjusting the weight value in the AnimationInstance. This can be used for blending between two or more animations.</p>"}]}